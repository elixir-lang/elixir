# Library Guidelines

This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries.

## Getting started

You can create a new Elixir library by running the `mix new` command:

    $ mix new my_library

The project name is given in the `snake_case` convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the [Naming Conventions](naming-conventions.html) document for more information.

Every project has a `mix.exs` file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a `lib` directory, which includes Elixir source code, and a `test` directory. A `src` directory may also exist for Erlang sources.

For more information on running your project, see the official [Mix & OTP guide](https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html) or [Mix documentation](https://hexdocs.pm/mix/Mix.html).

### Applications with supervision tree

The `mix new` command also allows the `--sup` flag to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.

## Publishing

Writing code is only the first of many steps to publish a package. We strongly recommend developers to:

  * Choose a versioning schema. Elixir requires versions to be in the format `MAJOR.MINOR.PATCH` but the meaning of those numbers is up to you. Most projects choose [Semantic Versioning](https://semver.org/).

  * Write tests. Elixir ships with a test-framework named [ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html) and the project generated by `mix new` includes sample tests and doctests.

  * Write documentation. The Elixir community is proud in treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. Projects like [ExDoc](https://github.com/elixir-lang/ex_doc) can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports writing "extra pages", like this one that you are reading, that augment the documetnation with tutorials, guides, and references. See the [Writing Documentation](writing-documentation.html) page for more information.

Projects are often made available to other developers [by publishing a Hex package](https://hex.pm/docs/publish). Hex also [supports private packages for organizations](https://hex.pm/pricing).

Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc) and also made available on [HexDocs](https://hexdocs.pm).

## Anti-patterns

In this section we document common anti-patterns to avoid when writing libraries.

### Avoid using exceptions for control-flow

You should avoid using exceptions for control-flow. For example, instead of:

```elixir
try do
  contents = File.read!("some_path_that_may_or_may_not_exist")
  {:it_worked, contents}
rescue
  File.Error ->
    :it_failed
end
```

you should prefer:

```elixir
case File.read("some_path_that_may_or_may_not_exist") do
  {:ok, contents} -> {:it_worked, contents}
  {:error, _} -> :it_failed
end
```

As a library author, it is your responsibility to make sure users are not required to use exceptions for control-flow in their applications. You can follow the same convention as Elixir here, using function names without `!` for returning `:ok`/`:error` tuples and appending `!` to those function names for the raising version.

It is important to note that a name without `!` does not mean a function will never raise. For example, even `File.read/1` can fail in case of bad arguments:

```iex
iex> File.read(1)
** (FunctionClauseError) no function clause matching in IO.chardata_to_string/1
```

The usage of `:ok`/`:error` tuples is about the domain that the function works on, in this case, filesystem access. Bad arguments, logical errors, invalid options should raise regardless of the function name. 

### Avoid application configuration

You should avoid using [the application environment](https://hexdocs.pm/elixir/Application.html#get_env/2) for configuring your own libraries. The application environment is **global** which means it becomes impossible for two dependencies to use your library in two different ways.

Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash `-` character:

```elixir
defmodule DashSplitter do
  def split(string) when is_binary(string) do
    String.split(string, "-", parts: 2)
  end
end
```

Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment:

```elixir
def split(string) when is_binary(string) do
  parts = Application.get_env(:dash_splitter, :parts, 2)
  String.split(string, "-", parts: parts)
end
```

Now users can configure your library in their `config/config.exs` file as follows:

```elixir
config :dash_splitter, :parts, 3
```

Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts.

The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could use a keyword list:

```elixir
def split(string, opts \\ []) when is_binary(string) and is_list(opts) do
  parts = Keyword.get(opts, :parts, 2)
  String.split(string, "-", parts: parts)
end
```

In case you need to configure a process, the options should be passed when starting that process. 

The application environment should be reserved only for configurations that are truly global, for example, to control your application boot process and its supervision tree.

### Avoid `use` when an `import` is enough

A library should not provide `use MyLib` functionality if all `use MyLib` does is to `import`/`require` the module itself. For example, this is an anti-pattern:

```elixir
defmodule MyLib do
  defmacro __using__(_) do
    quote do
      import MyLib # or require MyLib
    end
  end

  def some_fun(arg1, arg2) do
    ...
  end
end
```

The reason why defing the `__using__` macro above should be avoided is because when a developer writes:

```elixir
defmodule MyApp do
  use MyLib
end
```

it allows `use MyLib` to run *any* code into the `MyApp` module. For someone reading the code, it is impossible to assess the impact that `use MyLib` has in a module without looking at the implementation of `__using__`.

The following code is much clearer:

```elixir
defmodule MyApp do
  import MyLib
end
```

The code above says we are only bringing in the functions from `MyLib` so we can invoke `some_fun(arg1, arg2)` directly without the `MyLib.` prefix. Even more important, `import MyLib` says that we have an option to not `import MyLib` at all as we can simply invoke the function as `MyLib.some_fun(arg1, arg2)`.

While there are many situations where using a module is required, `use` should be skipped when all it does is to `import` or `require` a module. `import` and `require` are a simpler contract that gives users of your library more control on how to design and maintain their code. 

### Avoid macros

Although the previous section could be summarized as "avoid macros", both topics are important enough to deserve their own section.

To quote [the official guide on Macros](https://elixir-lang.org/getting-started/meta/macros.html):

> Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it’s considered to be bad style to use them when they’re not necessary. So write macros responsibly.
>
> Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that **explicit is better than implicit**. **Clear code is better than concise code**.

When you absolutely have to use macro, make sure that a macro is not the only way the user can interface with your library and keep the amount of code generated by a macro to a minimum.

### Avoid spawning unsupervised processes

You should avoid spawning processes outside of a supervision tree, especially long-running ones. Instead, processes must be started inside supervision trees. This guarantees developers have full control over the initialization, restarts, and shutdown of the system.

If your application does not have a supervision tree, one can be added by changing `def application` inside `mix.exs` to include a `:mod` key with the application callback name:

```elixir
def application do
  [
    extra_applications: [:logger],
    mod: {MyApp.Application, []}
  ]
end
```

and then defining a `my_app/application.ex` file with the following template:

```elixir
defmodule MyApp.Application do
    # See https://hexdocs.pm/elixir/Application.html
    # for more information on OTP Applications
    @moduledoc false

    use Application

    def start(_type, _args) do
      # List all child processes to be supervised
      children = [
        # Starts a worker by calling: MyApp.Worker.start_link(arg)
        # {MyApp.Worker, arg},
      ]

      # See https://hexdocs.pm/elixir/Supervisor.html
      # for other strategies and supported options
      opts = [strategy: :one_for_one, name: MyApp.Supervisor]
      Supervisor.start_link(children, opts)
    end
  end
end
```

This is the same template generated by `mix new --sup`.

Each process started with the application must be listed as a child under the `Supervisor` above. We call those "static processes" because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the `DynamicSupervisor` module.

One of the few times where it is acceptable to start a process outside of a supervision tree is with `Task.async/1` and `Task.await/2`. But this exception applies only to `Task.async/1` (and not `Task.start_link/1`) and you must always call `Task.await/2` after starting a task with `Task.async/1`.
