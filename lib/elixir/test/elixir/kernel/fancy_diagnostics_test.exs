Code.require_file("../test_helper.exs", __DIR__)

defmodule Kernel.FancyDiagnosticsTest do
  use ExUnit.Case, async: false

  import ExUnit.CaptureIO

  setup do
    Code.put_compiler_option(:fancy_diagnostics, true)
    on_exit(fn -> Code.put_compiler_option(:fancy_diagnostics, false) end)
  end

  describe "compile-time exceptions" do
    test "SyntaxError (snippet)" do
      expected = """
      ** (SyntaxError) invalid syntax found on nofile:1:17:

         ┌─ error: nofile:1:17
         │
       1 │ [1, 2, 3, 4, 5, *]
         │                 ^
         │
         │ syntax error before: '*'
         │

          (elixir 1.16.0-dev) src/elixir_errors.erl:584: :elixir_errors.raise/3
          test.exs:5: (file)
      """

      output = capture_raise("""
      [1, 2, 3, 4, 5, *]
      """, SyntaxError)
      
      refute ansi_error?(output)
      assert strip_ansi(output) == expected 
    end

    test "SyntaxError (line only)" do
      assert true
    end

    test "MissingTokenError (snippet)" do
      assert true
    end

    test "MissingTokenError (line only)" do
      assert true
    end

    test "respects disabled ansi" do
      Application.put_env(:elixir, :ansi_enabled, false)

      expected = """
      ** (SyntaxError) invalid syntax found on nofile:1:17:

         ┌─ error: nofile:1:17
         │
       1 │ [1, 2, 3, 4, 5, *]
         │                 ^
         │
         │ syntax error before: '*'
         │

          (elixir 1.16.0-dev) src/elixir_errors.erl:584: :elixir_errors.raise/3
          test.exs:5: (file)
      """

      output = capture_raise("""
      [1, 2, 3, 4, 5, *]
      """, SyntaxError)

      refute ansi_error?(output)
      assert output == expected 
    after
      Application.put_env(:elixir, :ansi_enabled, true)
      purge(Sample)
    end
  end

  describe "diagnostics" do
    # TODO: check with readable `file`

    test "grouped warnings (no file)" do
      expected = """
         ┌─ warning: nofile:3:6
         │
         │ A.bar/0 is undefined or private
         │
         │ Invalid call also found at 3 other locations:
         │   nofile:4:6: Sample.a/0
         │   nofile:5:6: Sample.a/0
         │   nofile:6:6: Sample.a/0
         │ 

      """

      output = capture_eval("""
      defmodule Sample do
        def a do 
          A.bar()
          A.bar()
          A.bar()
          A.bar()
        end
      end
      """) 
      
      assert ansi_warning?(output)
      assert strip_ansi(output) == expected 
    after
      purge(Sample)
    end

    test "warning (line only)" do
      expected = """
         ┌─ warning: nofile:2
         │
       2 │ function hello/0 is unused
         │

      """

      output = capture_eval("""
      defmodule Sample do
        defp hello, do: nil
      end
      """) 
      
      assert ansi_warning?(output)
      assert strip_ansi(output) == expected 
    after
      purge(Sample)
    end

    test "warning (line+column)" do
      expected = """
         ┌─ warning: nofile:5:5
         │
       5 │ module attribute @foo in code block has no effect as it is never returned (remove
         │ the attribute or assign it to _ to avoid warnings)
         │

      """

      output = capture_eval("""
      defmodule Sample do
        @foo 1

        def bar do
          @foo
          :ok
        end
      end
      """) 

      assert ansi_warning?(output)
      assert strip_ansi(output) == expected 
    after
      purge(Sample)
    end

    test "warning (no file)" do
      expected = """
         ┌─ warning: nofile:2:3
         │
       2 │ unused alias List
         │

      """

      output = capture_eval("""
      defmodule Sample do
        alias :lists, as: List
        import MapSet
        new()
      end
      """) 

      assert ansi_warning?(output)
      assert strip_ansi(output) == expected 
    after
      purge(Sample)
    end

    test "warning (long message)" do
      assert true
    end

    test "error (line only)" do
      assert true
    end

    test "error (line+column)" do
      expected = """
         ┌─ error: nofile:2:16
         │
       2 │ undefined function module_info/0 (this function is auto-generated by the compiler
         │ and must always be called as a remote, as in __MODULE__.module_info/0)
         │

      """

      output = capture_raise("""
      defmodule Sample do
        def foo, do: module_info()
      end
      """, CompileError)

      assert ansi_error?(output)
      assert strip_ansi(output) == expected 
    after
      purge(Sample)
    end

    test "error (long message)" do
      assert true
    end

    test "respects disabled ansi" do
      Application.put_env(:elixir, :ansi_enabled, false)

      expected = """
         ┌─ error: nofile:1:1
         │
       1 │ undefined variable "foo"
         │

      """

      output = capture_raise("""
      foo
      """, CompileError) 

      refute ansi_error?(output)
      assert output == expected 
    after
      Application.put_env(:elixir, :ansi_enabled, true)
    end
  end

  defp capture_eval(source) do
    capture_io(:stderr, fn ->
      quoted = Code.string_to_quoted!(source, columns: true)
      Code.eval_quoted(quoted)
    end)
  end

  defp capture_raise(source, exception) do 
    capture_io(:stderr, fn ->
      assert_raise exception, fn ->
        ast = Code.string_to_quoted!(source, columns: true)
        Code.eval_quoted(ast) 
      end
    end)
  end

  defp purge(module) when is_atom(module) do
    :code.purge(module)
    :code.delete(module)
  end

  defp ansi_warning?(output) do
    pattern = :binary.compile_pattern(["\e[33m", "\e[0m"])
    String.contains?(output, pattern)
  end

  defp ansi_error?(output) do
    pattern = :binary.compile_pattern(["\e[31m", "\e[0m"])
    String.contains?(output, pattern)
  end

  defp strip_ansi(output) do
    ansi_pattern = :binary.compile_pattern(["\e[33m", "\e[31m", "\e[0m"])
    String.replace(output, ansi_pattern, "")
  end
end
