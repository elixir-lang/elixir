defmodule ExUnit.Prop do
  @moduledoc """
  Property test support in ExUnit.

  Property tests use randomly generated data to test that a property holds for
  all valid inputs.

  To generate the data generator functions are used. Generator functions return
  test data or throw `:discard` (using the `discard/0` function or functions
  based on it, such as `satisfy/1`) to indicate that no test data was generated.

  For example here's a way to randomly generate numbers 1..10, except seven:

      gen = fun ->
              n = :random.uniform(10)
              satisfy (n != 7)
              n
            end

  Generators may also be tuples of a generator function and a shrink function.
  A shrink function takes data generated by a generator function and shrinks it
  (removes some of it). Shrink functions are used to get the smallest possible
  input that still fails.

  The shrink algorithm works like this: When a test fails the shrink function is
  called. If the shrink function returns an empty list the test failure is
  reported, with the latest (i.e. smallest input). If the shrink function
  returns a list of values the test is run for each of values in turn, if the
  test fails again it the test input that failed is used for a new round of
  shrinking, if all tests succeed the last failing input is reported.

  It's important to note that once a test fails for a given input all the other
  inputs that were generated by the shrink function in that round are discarded.
  This prevents shrinking from taking all too long. Still, you should be careful
  with how you write shrink functions, it's quite easy to get very exponential
  testing time.

  ## Use of the process store
 
  While generating input data the process store will be used to hold some key
  values, such as the size parameter (key `:eu_prop_test_size`) and the state of
  the random number generator (key determined by Erlang).

  ## Example 1: Testing Enum.reverse
  
  A very simple example of property testing is testing the `Enum.reverse`
  function for lists. Because `Enum.reverse` is defined in terms of
  `Enumerable.reduce` and not in terms of `:lists.reverse` it makes sense to
  test it against `:lists.reverse`.

  The first step will be to define a generator of random lists. Let's say a
  random list of integers between 1 and 1000.

      import ExUnit.Prop
      gen = fn -> list_of(fn -> :random.uniform(1000) end) end

  Next the test function is needed. The test function uses assertions like any
  unit test. Note how the test function takes one input argument, that's the
  value the test function generates.

      f = fn l -> assert Enum.reverse(l) == :lists.reverse(l) end

  This is run in a normal unit test using the prop function.

      test "Enum.reverse gives the same result as :lists.reverse for lists" do
        prop gen, f
      end

  If the test fails for some input the bad input will be printed.

  ## Example 2: Testing a bad reverse function with shrinking
  
  Generated inputs can be quite long, to use an understatement. Often only a
  small part of it is actually needed to demonstrate the error. To show only
  that part a shrink function can be given.

  Let's test a reverse function that secretly filters out the 1.

      def bad_reverse(l), do: do_bad_reverse(l, [])
      
      defp do_bad_reverse([], acc), do: acc
      defp do_bad_reverse([1|t], acc), do: do_bad_reverse(t, acc)
      defp do_bad_reverse([h|t], acc), do: do_bad_reverse(t, [h|acc])

      test "Enum.reverse gives the same result as :lists.reverse for lists" do
        import ExUnit.Prop
        gen = fn -> list_of(fn -> :random.uniform(10) end) end
        f = fn l -> assert bad_reverse(l) == :lists.reverse(l) end
        prop gen, f
      end

  The error is likely to be pretty long. So let's define a simple shrink
  function, this one cuts up lists in two halves. The test function will be run
  on each of the halves and will report the smallest input it can find using a
  pretty simple algorithm (for details see above) for which the error still
  occurs.

      def halves(l) do
        middle = div(length(l), 2)
        [Enum.take(l, middle), Enum.drop(l, middle)]
      end

  To use the shrink function pass a tuple of generator and shrink function to
  `prop`.

      test "Enum.reverse gives the same result as :lists.reverse for lists" do
        import ExUnit.Prop
        gen = fn -> list_of(fn -> :random.uniform(10) end) end
        f = fn l -> assert bad_reverse(l) == :lists.reverse(l) end
        prop { gen,  &halves/1 }, f
      end

  Now the generated test data should be smaller (on average).
  """

  @typedoc """
  Configuration for property tests.

  ## Options
  
  `max_successes`: Number of times to run the function at most. If this number is
                   10 if the test function has run 10 times without exceptions or
                   assertions failing the test has passed.
  `max_discards`:  How many times the generator may return an empty list before
                   the test is declared a failure because of a bad generator. This
                   is per invocation of the test function, so the generator can be
                   invoked quite a lot of times.
  `max_size`:      This influences the maximum length of lists using `list_of/1`
                   and other generators. The larger `max_size` the bigger (on
                   average) test input will be.
  `initial_seed`:  If set this is passed to `:random.seed/1` to initialize the
                   random number generator for the test.
  """
  @type config :: [
    max_succeses: pos_integer,
    max_discards: pos_integer,
    max_size:     pos_integer,
    initial_seed: :random.ran | nil
  ]

  @doc """
  Defaults for the property test configuration.

  This is mostly provided to make the test defaults easier to inspect from an
  iex session.
  """
  def default_config do
    [ max_successes: 100,
      max_discards: 100,
      max_size: 1000,
      initial_seed: nil ]
  end

  defexception BadGenerator, message: nil do
    @moduledoc """
    Thrown when a generator function didn't generate a value after a
    preconfigured number of attempts. 
    """
  end

  defexception PropertyError, input: nil, shrinks: 0, wrapped: nil do
    @moduledoc """
    A property error wraps an exception thrown to add some extra information.

    For example it contains the rather crucial information of the input data.
    """
    def message(PropertyError[input: input, shrinks: shrinks, 
                              wrapped: wrapped]) do
        "After #{shrinks} shrinks with input < #{inspect input} >: " <>
        "#{exception_string_for(wrapped)}"
    end

    defp exception_string_for({ k, t }) do
      case Exception.normalize(k, t) do
        e when is_exception(e) -> "(#{inspect elem(e, 0)}) #{e.message}"
        _                      -> "(#{inspect k}) #{inspect t}"
      end
    end
  end

  @doc """
  Run function `f` with data produced by the generator.
  """
  @spec prop((() -> any), ((any) -> none)) :: :ok
  @spec prop(config, (() -> any), ((any) -> none)) :: :ok
  def prop(cfg // [], generator, f) do
    cfg = Keyword.merge(default_config, cfg) 
    if cfg[:initial_seed] do
      :random.seed(cfg[:initial_seed])
    else
      # This prevents test from unduly influencing eachother in non-async mode.
      :random.seed(:erlang.now)
    end
    { gen, shrink } = if is_function(generator),
                        do: { generator, fn _ -> [] end },
                        else: generator
    with_size(cfg[:max_size], fn ->
      Enum.each(1..cfg[:max_successes], fn _ ->
        v = gen_input_value(gen, cfg[:max_discards], cfg[:max_discards])
        prop_rec(gen, shrink, f, 0, v)
      end)
    end)
  end

  # Run the test function, handling shrinks.
  defp prop_rec(gen, shrink, f, shrinks, v) do
    try do
      f.(v)
    catch
      # Due to Elixir's restriction on catching exception we'll use the Erlang
      # catching form. For properties the assumption that exits and throws are
      # not intended seems sane so catch those as well as errors.
      t, e ->
        alts = shrink.(v)
        case alts do
          [] -> nil # Fall to the raise statement below 
          _  ->
            Enum.each(alts, &prop_rec(gen, shrink, f, shrinks+1, &1))
            # If we reach this point none of the shrinked values have
            # caused the function to fail. Which means that this is the most
            # failing case.
        end
        raise PropertyError, input: v, shrinks: shrinks, wrapped: { t, e }
    end
  end

  # Run the input value generator as often as is needed or allowed to get a
  # value.
  defp gen_input_value(_, max_discards, 0) do
    raise BadGenerator, 
      message: "Could not generate input value in #{max_discards} attempts"
  end
  defp gen_input_value(generator, max_discards, attempts_left) do
    try do
      generator.()
    catch
      :throw, :discard ->
        gen_input_value(generator, max_discards, attempts_left - 1)
    end
  end

  @doc """
  Get the current test size.
  """
  def get_size() do
    Process.get(:eu_prop_test_size)
  end

  @doc """
  Run the function with the given test size.

  After the function has run the test size is restored.

  If the test size is a function it is passed the original test size.
  """
  def with_size(sz, f) when is_integer(sz), do: with_size(fn _ -> sz end, f)
  def with_size(sz, f) when is_function(sz) do
    old = Process.get(:eu_prop_test_size)
    try do
      Process.put(:eu_prop_test_size, sz.(old))
      f.()
    after
      Process.put(:eu_prop_test_size, old)
    end
  end

  @doc """
  Indicate that the generator will not generate a value this time.
  """
  def discard() do
    throw :discard
  end

  @doc """
  If the argument is `false` or `nil` call `discard/0`. Otherwise this is a no-op.
  """
  # Use `if` to test for "falsy" values.
  def satisfy(b) do
    if b do :ok else discard() end
  end

  @doc """
  Randomly returns one of the values from the enumerable using an uniform
  distribution.

  The enumerable must be convertable to a list with at least one value.
  """
  @spec one_of(Enumerable.t) :: any
  def one_of(collection) do
    case Enum.to_list(collection) do
      []   ->
        raise ArgumentError, message: 
          "could not convert collection to nonempty list: #{inspect collection}"
      list ->
        length = length(list)
        :lists.nth(:random.uniform(length), list)
    end
  end

  @doc """
  Returns a list of zero or more values generated with the anonymous function.

  The list will not be longer than the test size value.
  """
  @spec list_of((() -> any)) :: [any]
  def list_of(f) do
    sz = get_size()
    n = :random.uniform(sz+1) - 1
    do_list_of(f, n, [])
  end

  # Ranges are inclusive which rules them out for writing this loop
  defp do_list_of(_, 0, acc), do: acc
  defp do_list_of(f, n, acc), do: do_list_of(f, n-1, [f.() | acc])

  @doc """
  Returns a list of one or more values generated with the anonymous function.

  The list will not be longer than the test size value.
  """
  @spec list_of1((() -> any)) :: [any]
  def list_of1(f) do
    sz = get_size()
    n = :random.uniform(sz)
    Enum.map(1..n, fn _ -> f.() end)
  end
end
