defmodule ExUnit.Prop do
  @moduledoc """
  Property test support in ExUnit.

  Property tests use randomly generated data to test that a property holds for
  all valid inputs.

  To generate the data generator functions are used. Generator functions return
  test data or throw `:discard` (using the `discard/0` function or functions
  based on it, such as `satisfy/1`) to indicate that no test data was generated.

  For example here's a way to randomly generate numbers 1..10, except seven:

      gen = fun ->
              n = :random.uniform(10)
              satisfy (n != 7)
              n
            end

  Generators may also be tuples of a generator function and a shrink function.
  A shrink function takes data generated by a generator function and shrinks it
  (removes some of it). Shrink functions are used to get the smallest possible
  input that still fails.

  The shrink algorithm works like this: When a test fails the shrink function is
  called. If the shrink function returns an empty list the test failure is
  reported, with the latest (i.e. smallest input). If the shrink function
  returns a list of values the test is run for each of values in turn, if the
  test fails again it the test input that failed is used for a new round of
  shrinking, if all tests succeed the last failing input is reported.

  It's important to note that once a test fails for a given input all the other
  inputs that were generated by the shrink function in that round are discarded.
  This prevents shrinking from taking all too long. Still, you should be careful
  with how you write shrink functions, it's quite easy to get very exponential
  testing time.

  ## Use of the process store
 
  While generating input data the process store will be used to hold some key
  values, such as the size parameter (key `:eu_prop_test_size`) and the state of
  the random number generator (key determined by Erlang).
  """

  defrecord Config, max_successes: 100,
                    max_discards: 100,
                    max_size: 1000,
                    initial_seed: nil do
    @moduledoc """
    Configuration for property tests.

    ## Fields
    
    `max_successes`: Number of times to run the function at most. If this number is
                     10 if the test function has run 10 times without exceptions or
                     assertions failing the test has passed.
    `max_discards`:  How many times the generator may return an empty list before
                     the test is declared a failure because of a bad generator. This
                     is per invocation of the test function, so the generator can be
                     invoked quite a lot of times.
    `max_size`:      This influences the maximum length of lists using `list_of/1`
                     and other generators. The larger `max_size` the bigger (on
                     average) test input will be.
    `initial_seed`:  If set this is passed to `:random.seed/1` to initialize the
                     random number generator for the test.
    """
    record_type max_successes: pos_integer,
                max_discards: pos_integer,
                initial_seed: :random.ran | nil
  end
 
  defexception BadGenerator, message: nil do
    @moduledoc """
    Thrown when a generator function didn't generate a value after a
    preconfigured number of attempts. 
    """
  end

  defexception PropertyError, input: nil, shrinks: 0, wrapped: nil do
    @moduledoc """
    A property error wraps an exception thrown to add some extra information.

    For example it contains the rather crucial information of the input data.
    """
    def message(PropertyError[input: input, shrinks: shrinks, 
                              wrapped: wrapped]) do
        "After #{shrinks} shrinks with input < #{inspect input} >: " <>
        "#{exception_string_for(wrapped)}"
    end

    defp exception_string_for({ k, t }) do
      case Exception.normalize(k, t) do
        e when is_exception(e) -> "(#{inspect elem(e, 0)}) #{e.message}"
        _                      -> "(#{inspect k}) #{inspect t}"
      end
    end
  end

  @doc """
  Run function `f` with data produced by the generator.
  """
  @spec prop((() -> any), ((any) -> none)) :: :ok
  @spec prop(Config.t, (() -> any), ((any) -> none)) :: :ok
  def prop(config // Config[], generator, f) do
    if config.initial_seed do
      :random.seed(config.initial_seed)
    else
      # This prevents test from unduly influencing eachother in non-async mode.
      :random.seed(:erlang.now)
    end
    { gen, shrink } = if is_function(generator),
                        do: { generator, fn _ -> [] end },
                        else: generator
    with_size(config.max_size, fn ->
      Enum.each(1..config.max_successes, fn _ ->
        v = gen_input_value(gen, config.max_discards, config.max_discards)
        prop_rec(config, gen, shrink, f, 0, v)
      end)
    end)
  end

  # Run the test function, handling shrinks.
  defp prop_rec(config, gen, shrink, f, shrinks, v) do
    try do
      f.(v)
    catch
      # Due to Elixir's restriction on catching exception we'll use the Erlang
      # catching form. For properties the assumption that exits and throws are
      # not intended seems sane so catch those as well as errors.
      t, e ->
        alts = shrink.(v)
        case alts do
          [] -> nil # Fall to the raise statement below 
          _  ->
            Enum.each(alts, &prop_rec(config, gen, shrink, f, shrinks+1, &1))
            # If we reach this point none of the shrinked values have
            # caused the function to fail. Which means that this is the most
            # failing case.
        end
        raise PropertyError, input: v, shrinks: shrinks, wrapped: { t, e }
    end
  end

  # Run the input value generator as often as is needed or allowed to get a
  # value.
  defp gen_input_value(_, max_discards, 0) do
    raise BadGenerator, 
      message: "Could not generate input value in #{max_discards} attempts"
  end
  defp gen_input_value(generator, max_discards, attempts_left) do
    try do
      generator.()
    catch
      :throw, :discard ->
        gen_input_value(generator, max_discards, attempts_left - 1)
    end
  end

  @doc """
  Get the current test size.
  """
  def get_size() do
    Process.get(:eu_prop_test_size)
  end

  @doc """
  Run the function with the given test size.

  After the function has run the test size is restored.

  If the test size is a function it is passed the original test size.
  """
  def with_size(sz, f) when is_integer(sz), do: with_size(fn _ -> sz end, f)
  def with_size(sz, f) when is_function(sz) do
    old = Process.get(:eu_prop_test_size)
    try do
      Process.put(:eu_prop_test_size, sz.(old))
      f.()
    after
      Process.put(:eu_prop_test_size, old)
    end
  end

  @doc """
  Indicate that the generator will not generate a value this time.
  """
  def discard() do
    throw :discard
  end

  @doc """
  If the argument is `false` or `nil` call `discard/0`. Otherwise this is a no-op.
  """
  # Use `if` to test for "falsy" values.
  def satisfy(b) do
    if b do :ok else discard() end
  end

  @doc """
  Randomly returns one of the values from the enumerable using an uniform
  distribution.

  The enumerable must be convertable to a list with at least one value.
  """
  @spec one_of(Enumerable.t) :: any
  def one_of(collection) do
    case Enum.to_list(collection) do
      []   ->
        raise ArgumentError, message: 
          "could not convert collection to nonempty list: #{inspect collection}"
      list ->
        length = length(list)
        :lists.nth(:random.uniform(length), list)
    end
  end

  @doc """
  Returns a list of zero or more values generated with the anonymous function.

  The list will not be longer than the test size value.
  """
  @spec list_of((() -> any)) :: [any]
  def list_of(f) do
    sz = get_size()
    n = :random.uniform(sz+1) - 1
    do_list_of(f, n, [])
  end

  # Ranges are inclusive which rules them out for writing this loop
  defp do_list_of(_, 0, acc), do: acc
  defp do_list_of(f, n, acc), do: do_list_of(f, n-1, [f.() | acc])

  @doc """
  Returns a list of one or more values generated with the anonymous function.

  The list will not be longer than the test size value.
  """
  @spec list_of1((() -> any)) :: [any]
  def list_of1(f) do
    sz = get_size()
    n = :random.uniform(sz)
    Enum.map(1..n, fn _ -> f.() end)
  end
end
